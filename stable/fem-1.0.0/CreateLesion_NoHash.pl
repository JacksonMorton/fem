#!/usr/bin/perl -w
# 
# CreateLesion1.0.pl - determine the elements that fall w/i a
# specfied radius of a center point, and assign them different
# material properties than the background material
#
# INPUTS:
#	NodeFile (string) - file containing the *NODE information
#	(generated by ParseElemsNodes)
# ElemFile (string) - file containing the *ELEMENT_SOLID
# information (generated by ParseElemsNodes)
# CenterX (float) - x-coordinate of center point (mesh units)
# CenterY (float) - y-coordinate of center point (mesh units)
# CenterZ (float) - z-coordinate of center point (mesh units)
# Radius (float) - radius of sphere (mesh units)
#
# OUTPUT:
# lesion.dyn - ASCII file with the new *ELEMENT_SOLID data
# sphere elements are assigned part #2, while background is
# part #1
#
# Mark 05/13/05

# check that the correct number of input arguments are
# provided (6)
if(($#ARGV+1) != 6) { die "Wrong number of input arguments (!=6)" }

$CenterX = "$ARGV[2]";
$CenterY = "$ARGV[3]";
$CenterZ = "$ARGV[4]";
$Radius = "$ARGV[5]";

# open up the files with the nodal and element information
open(NODEFILE,"<$ARGV[0]") || die "The node input file couldn't be opened!";
open(ELEMFILE,"<$ARGV[1]") || die "The element input file couldn't be opened!";

# check to make sure that lesion.dyn doesn't already exist so
# that we don't clobber a valid file; if it doesn't exist, then
# create the output file
if (-e 'lesion.dyn') {
  die "lesion.dyn already exists!"
  }
else {
  open(LESIONFILE,'> lesion.dyn');
  print LESIONFILE "*ELEMENT_SOLID\n";
  }

# read in the nodes and see which ones fall within the sphere
# that has been specfied by the user
print "Reading and processing node data\n";
# initialize the index of lesion nodes found to 0
$NodeCount = 0;
$LN_count = 0;

# initialize the @LN array
for ($i = 0; $i < 9999999; ++$i) {
	$LN[$i] = 0;
}

while(<NODEFILE>) {
	# remove the EOL character
  chomp;

  # split the line into data fields with spaces as the
  # delimiting character  
  @fields = split(' ',$_);

  # the actual node IDs and coordinates occupy 4 columns (the
  # header and footer are only a single column)
  if( ($#fields + 1) == 4) {
		$NodeCount = ++$NodeCount;
		$NodeRadius = sqrt(($fields[1] - $CenterX)**2 + ($fields[2] - $CenterY)**2 + ($fields[3] - $CenterZ)**2);
		if($NodeRadius < $Radius) {
			$LN[$fields[0]] = 1;
			$LN_count = ++$LN_count;
		}
	}
}

print $LN_count." lesion nodes found out of ".$NodeCount." total nodes\n";
close(NODEFILE);

print "Check the delimiting character (, ) for the element data!\n";

while(<ELEMFILE>) {
  # remove the EOL character
  chomp;

  # split the line into data fields with spaces as the
  # delimiting character  
  @fields = split(',',$_);
  #@fields = split(' ',$_);

  # the element ID and part ID are the first two columns; the
  # following 8 are the nodes associated with that element
  if( ($#fields + 1) == 10) {
		# check to see if any of the nodes for this element match
		# the nodes that are in the lesion nodes (@LN); if so,
		# change the part ID -> 2
		if($LN[$fields[2]] == 1 || $LN[$fields[3]] == 1 || $LN[$fields[4]] == 1 || $LN[$fields[5]] == 1 || $LN[$fields[6]] == 1 || $LN[$fields[7]] == 1 || $LN[$fields[8]] == 1 || $LN[$fields[9]] == 1) {
			$fields[1] = 2;
			print LESIONFILE join(",",@fields)."\n";
		}
		else {
			$fields[1] = 1;
			print LESIONFILE join(",",@fields)."\n";
		}
  }
}

close(ELEMFILE);

# print the footer and close lesion.dyn
print LESIONFILE "*END\n";
close(LESIONFILE);

print "Done writing element data to lesion.dyn\n";
