The binary/ascii file "binout" will eventually contain all the
data currently being put out to the various ascii files (nodout, matsum, etc).
The overall structure is like this:

For each ascii file the user has output, a subdirectory of the root is created
with the default name for that ascii file.  For example, if the user requests
nodout and rwforc output, there are two main subdirectories created, namely
"/nodout" and "/rwforc".  Each such directory contains further subdirectories
which contain the actual data.  The layout of these subdirectories is,
generally, like this: "metadata" contains information about the data contained
in the output (node ids and the like), and various directories "dxxxxxx" (where
xxxxxx is a 6 digit number, starting at 000001 and increasing by 1 each time)
which hold the actual output data.  Within each output type (nodout, rwforc,
etc), each dxxxxxx directory contains the same arrays of data.

Here is a list of the information contained in each primary directory:


===============================================================================
/secforc  -- Cross sectional forces
  /secforc/metadata/title:   I*1(80) = title from ls-dyna input file
  /secforc/metadata/version: I*1(10) = version string from dyna
  /secforc/metadata/date:    I*1(10) = date string from dyna
  /secforc/metadata/ids: integer(*) = list of id numbers for cross section
                                      definitions.
  /secforc/metadata/legend: I*1(*) = strings to be printed in the legend --
                              each is 70 characters long, and they are
                              concatenated, so 4 legend entries=280 characters
  /secforc/metadata/legend_ids: integer(*) = list of id numbers to be printed
                              in the legend.
  /secforc/metadata/rigidbody:integer(*) = rigid body number (one per
                              cross section).  If not 0, output is in the
                              local coord system of this rigid body.
  /secforc/metadata/accelerometer: integer(*) = accelerometer number (one per
                              cross section).  If not 0, output is in the
                              local coord system of this accelerometer.

 /secforc/d000001/time:		real(1) = current simulation time
 /secforc/d000001/x_force:	real(*) = X component of force (1 per section)
 /secforc/d000001/y_force:	real(*) = Y component of force
 /secforc/d000001/z_force:	real(*) = Z component of force
 /secforc/d000001/x_moment:	real(*) = X moment
 /secforc/d000001/y_moment:	real(*) = Y moment
 /secforc/d000001/z_moment:	real(*) = Z moment
 /secforc/d000001/total_force:	real(*) = total force
 /secforc/d000001/total_moment:	real(*) = total moment
 /secforc/d000001/x_centroid:	real(*) = X centroid
 /secforc/d000001/y_centroid:	real(*) = Y centroid
 /secforc/d000001/z_centroid:	real(*) = Z centroid
 /secforc/d000001/area:		real(*) = Area

===============================================================================
/rwforc  -- Rigid Wall Force data
  There may be some rigid walls with segments defined.  For this reason,
  another level of directory is defined.  For example, if rigid walls 2 and 5
  have segments defined, then there will be three top level directories:

  /rwforc/forces
  /rwforc/wall002
  /rwforc/wall005

 each of these directories contains a subdir with similar data:

  ./metadata/title: I*1(80) = title from ls-dyna input file
  ./metadata/version: I*1(10) = version string from dyna
  ./metadata/date:    I*1(10) = date string from dyna
  ./metadata/ids: integer(*) = list of id numbers for rigid walls (or segments)
  ./metadata/legend: I*1(*) = strings to be printed in the legend --
                              each is 70 characters long, and they are
                              concatenated, so 4 legend entries=280 characters
  ./metadata/legend_ids: integer(*) = list of id numbers to be printed
                              in the legend.

 The data written out each cycle:

 forces/d000001/time:		real(1) = current simulation time
 forces/d000001/Normal_Force:	real(*) = normal force for each wall
 forces/d000001/x_force:	real(*) = X force for each wall
 forces/d000001/y_force:	real(*) = Y force for each wall
 forces/d000001/z_force:	real(*) = Z force for each wall

 wall002/d000001/time:	        real(1) = current simulation time
 wall002/d000001/x_force:	real(*) = X force for each segment
 wall002/d000001/y_force:	real(*) = Y force for each segment
 wall002/d000001/z_force:	real(*) = Z force for each segment
 wall002/d000001/total_x:	real    = Total X force on wall
 wall002/d000001/total_y:	real    = Total Y force on wall
 wall002/d000001/Total_z:	real    = Total Z force on wall


===============================================================================
/nodout  -- Node data
  /nodout/metadata/title: I*1(80) = title from ls-dyna input file
  /nodout/metadata/version: I*1(10) = version string from dyna
  /nodout/metadata/date:    I*1(10) = date string from dyna
  /nodout/metadata/ids: integer(*) = list of user numbers for nodes
  /nodout/metadata/legend: I*1(*) = strings to be printed in the legend --
                              each is 70 characters long, and they are
                              concatenated, so 4 legend entries=280 characters
  /nodout/metadata/legend_ids: integer(*) = list of id numbers to be printed
                              in the legend.

 /nodout/d000001/time:		real(1) = current simulation time
 /nodout/d000001/cycle:		integer(1) = current simulation time step
 /nodout/d000001/x_displacement:real(*) = X disp, one for each node
 /nodout/d000001/y_displacement:real(*) = Y disp
 /nodout/d000001/z_displacement:real(*) = Z disp
 /nodout/d000001/x_velocity:	real(*) = X velocity
 /nodout/d000001/y_velocity:	real(*) = Y velocity
 /nodout/d000001/z_velocity:	real(*) = Z velocity
 /nodout/d000001/x_acceleration:real(*) = X acc
 /nodout/d000001/y_acceleration:real(*) = Y acc
 /nodout/d000001/z_acceleration:real(*) = Z acc
 /nodout/d000001/x_coordinate:	real(*) = X coord
 /nodout/d000001/y_coordinate:	real(*) = Y coord
 /nodout/d000001/z_coordinate:	real(*) = Z coord
 /nodout/d000001/rx_displacement:real(*)= X rotational disp
 /nodout/d000001/ry_displacement:real(*)= X rotational disp
 /nodout/d000001/rz_displacement:real(*)= X rotational disp
 /nodout/d000001/rx_velocity:	real(*) = X rotational velocity
 /nodout/d000001/ry_velocity:	real(*) = Y rotational velocity
 /nodout/d000001/rz_velocity:	real(*) = Z rotational velocity
 /nodout/d000001/rx_acceleration:real(*)= X rotational acc
 /nodout/d000001/ry_acceleration:real(*)= Y rotational acc
 /nodout/d000001/rz_acceleration:real(*)= Z rotational acc

The rotational components won't appear if the problem only has 3 degrees
of freedom.

===============================================================================
/elout  -- Element output data.  This is laid out a bit differently -- there
           are different subdirectories for each of the 4 element
           types, and there are no ids in the metadata directories (because
           elements can disappear due to erosion).

  /elout/solid/metadata/title: I*1(80)  = title from ls-dyna input file
  /elout/solid/metadata/version: I*1(10) = version string from dyna
  /elout/solid/metadata/date:    I*1(10) = date string from dyna
  /elout/solid/metadata/states: I*1(32) = comma separated list of names
         corresponding to the "state" of the element.  This string currently
         reads "elastic,plastic,failure,   ,temp".  See the "state" array below.
  /elout/solid/metadata/legend: I*1(*) = strings to be printed in the legend --
                              each is 70 characters long, and they are
                              concatenated, so 4 legend entries=280 characters
  /elout/solid/metadata/legend_ids: integer(*) = list of id numbers to be printed
                              in the legend.

  /elout/thickshell/metadata/title: I*1(80)  = title from ls-dyna input file
  /elout/thickshell/metadata/version: I*1(10) = version string from dyna
  /elout/thickshell/metadata/date:    I*1(10) = date string from dyna
  /elout/thickshell/metadata/states: I*1(32) = comma separated list of names
         corresponding to the "state" of the element.  This string currently
         reads "elastic,plastic,failure,   ,temp".  See the "state" array below.
  /elout/thickshell/metadata/system: I*1(6) = 'local ' or 'global' depending
         on whether the thickshell data is output in the local or global
         system.
  /elout/thickshell/metadata/legend: I*1(*) = strings to be printed in the legend --
                              each is 70 characters long, and they are
                              concatenated, so 4 legend entries=280 characters
  /elout/thickshell/metadata/legend_ids: integer(*) = list of id numbers to be printed
                              in the legend.

  /elout/shell/metadata/title: I*1(80)  = title from ls-dyna input file
  /elout/shell/metadata/version: I*1(10) = version string from dyna
  /elout/shell/metadata/date:    I*1(10) = date string from dyna
  /elout/shell/metadata/states: I*1(32) = comma separated list of names
         corresponding to the "state" of the element.  This string currently
         reads "elastic,plastic,failure,   ,temp".  See the "state" array below.
  /elout/shell/metadata/system: I*1(6) = 'local ', 'global' or 'lamina'
         depending on the system in which the data is output.
  /elout/shell/metadata/legend: I*1(*) = strings to be printed in the legend --
                              each is 70 characters long, and they are
                              concatenated, so 4 legend entries=280 characters
  /elout/shell/metadata/legend_ids: integer(*) = list of id numbers to be printed
                              in the legend.

  /elout/beam/metadata/title: I*1(80)  = title from ls-dyna input file
  /elout/beam/metadata/version: I*1(10) = version string from dyna
  /elout/beam/metadata/date:    I*1(10) = date string from dyna
  /elout/beam/metadata/legend: I*1(*) = strings to be printed in the legend --
                              each is 70 characters long, and they are
                              concatenated, so 4 legend entries=280 characters
  /elout/beam/metadata/legend_ids: integer(*) = list of id numbers to be printed
                              in the legend.

Data for each time step:

  solid/d000001/time:		real(1) = current simulation time
  solid/d000001/cycle:		integer(1) = problem cycle
  solid/d000001/ids:		integer(*) = list of element ids
  solid/d000001/mtype:		integer(*) = material type
  solid/d000001/state:		integer(*) = integer in the range 1-5
				according to the state of the element
				(translate to names from the
				"metadata/states" array)
  solid/d000001/sig_xx:		real(*) = sig_xx
  solid/d000001/sig_yy:		real(*) = sig_yy
  solid/d000001/sig_zz:		real(*) = sig_zz
  solid/d000001/sig_xy:		real(*) = sig_xy
  solid/d000001/sig_yz:		real(*) = sig_yz
  solid/d000001/sig_zx:		real(*) = sig_zx
  solid/d000001/yield:		real(*) = yield
  solid/d000001/effsg:		real(*) = effsg

  (if strain output was requested, there are also arrays output for
   eps_xx, eps_yy, eps_zz, eps_xy, eps_yz, eps_zx)

The following data is output for thickshell elements:

  thickshell/d000001/time:	real(1) = current simulation time
  thickshell/d000001/cycle:	integer(1) = problem cycle
  thickshell/d000001/ids:	integer(*) = list of element ids
  thickshell/d000001/mat:	integer(*) = material type
  thickshell/d000001/nip:	integer(*) = number of integration points
				for each element

 (these next arrays are equal in size to the TOTAL number of integration points
 taken over ALL thick shell elements, in order)

  thickshell/d000001/state:	integer(*) = integer in the range 1-5
				according to the state of the element
				(translate to names from the
				"metadata/states" array)
  thickshell/d000001/sig_xx:	real(*) = sig_xx
  thickshell/d000001/sig_yy:	real(*) = sig_yy
  thickshell/d000001/sig_zz:	real(*) = sig_zz
  thickshell/d000001/sig_xy:	real(*) = sig_xy
  thickshell/d000001/sig_yz:	real(*) = sig_yz
  thickshell/d000001/sig_zx:	real(*) = sig_zx
  thickshell/d000001/yield:	real(*) = yield
  thickshell/d000001/effsg:	real(*) = effsg

  these are also output (one per element) if strain data is requested:

  thickshell/d000001/lower_eps_xx:	real(*) = lower_eps_xx
  thickshell/d000001/lower_eps_yy:	real(*) = lower_eps_yy
  thickshell/d000001/lower_eps_zz:	real(*) = lower_eps_zz
  thickshell/d000001/lower_eps_xy:	real(*) = lower_eps_xy
  thickshell/d000001/lower_eps_yz:	real(*) = lower_eps_yx
  thickshell/d000001/lower_eps_zx:	real(*) = lower_eps_zx
  thickshell/d000001/upper_eps_xx:	real(*) = upper_eps_xx
  thickshell/d000001/upper_eps_yy:	real(*) = upper_eps_yy
  thickshell/d000001/upper_eps_zz:	real(*) = upper_eps_zz
  thickshell/d000001/upper_eps_xy:	real(*) = upper_eps_xy
  thickshell/d000001/upper_eps_yz:	real(*) = upper_eps_yx
  thickshell/d000001/upper_eps_zx:	real(*) = upper_eps_zx

Similarly, for shell elements we have:

  shell/d000001/time:	real(1) = current simulation time
  shell/d000001/cycle:	integer(1) = problem cycle
  shell/d000001/ids:	integer(*) = list of element ids
  shell/d000001/mat:	integer(*) = material type
  shell/d000001/nip:	integer(*) = number of integration points
			for each element
  shell/d000001/iop:	integer(*) = ???? one per element

 (these next arrays are equal in size to the TOTAL number of integration points
 taken over ALL shell elements, in order)

  shell/d000001/state:	integer(*) = integer in the range 1-5
			according to the state of the element
			(translate to names from the
			"metadata/states" array)
  shell/d000001/sig_xx:	real(*) = sig_xx
  shell/d000001/sig_yy:	real(*) = sig_yy
  shell/d000001/sig_zz:	real(*) = sig_zz
  shell/d000001/sig_xy:	real(*) = sig_xy
  shell/d000001/sig_yz:	real(*) = sig_yz
  shell/d000001/sig_zx:	real(*) = sig_zx
  shell/d000001/plastic_strain:	real(*) = plastic_strain

  these are also output (one per element) if strain data is requested:

  shell/d000001/lower_eps_xx:	real(*) = lower_eps_xx
  shell/d000001/lower_eps_yy:	real(*) = lower_eps_yy
  shell/d000001/lower_eps_zz:	real(*) = lower_eps_zz
  shell/d000001/lower_eps_xy:	real(*) = lower_eps_xy
  shell/d000001/lower_eps_yz:	real(*) = lower_eps_yx
  shell/d000001/lower_eps_zx:	real(*) = lower_eps_zx
  shell/d000001/upper_eps_xx:	real(*) = upper_eps_xx
  shell/d000001/upper_eps_yy:	real(*) = upper_eps_yy
  shell/d000001/upper_eps_zz:	real(*) = upper_eps_zz
  shell/d000001/upper_eps_xy:	real(*) = upper_eps_xy
  shell/d000001/upper_eps_yz:	real(*) = upper_eps_yx
  shell/d000001/upper_eps_zx:	real(*) = upper_eps_zx

Similarly, for beam elements we have:

  beam/d000001/time:	real(1) = current simulation time
  beam/d000001/cycle:	integer(1) = problem cycle
  beam/d000001/ids:	integer(*) = list of element ids
  beam/d000001/mat:	integer(*) = material type
  beam/d000001/nip:	integer(*) = number of integration points
  beam/d000001/axial:	real(*) = axial
  beam/d000001/shear-s:	real(*) = shear-s
  beam/d000001/shear-t:	real(*) = shear-t
  beam/d000001/moment-s:real(*) = moment-s
  beam/d000001/moment-t:real(*) = moment-t
  beam/d000001/torsion:	real(*) = torsion

And, with one entry for every integration point:

  beam/d000001/sigma_11:	real(*) = sigma_11
  beam/d000001/sigma_12:	real(*) = sigma_12
  beam/d000001/sigma_31:	real(*) = sigma_31
  beam/d000001/plastic_eps:	real(*) = plastic_eps

===============================================================================
/glstat  -- Global system statistics.
  /glstat/metadata/title: i I*1(80) = title from ls-dyna input file
  /glstat/metadata/version: I*1(10) = version string from dyna
  /glstat/metadata/date:    I*1(10) = date string from dyna
  /glstat/metadata/element_types: I*1(54) = comma separated list of names
         corresponding to the type of element that might currently be
         controlling the timestep.  This string currently
         reads "solid,beam,shell,tshell,spring,seatbelt,load curve,sph"

  /glstat/d000001/time:		real(1) = current simulation time
  /glstat/d000001/time_step:	real(1) = current timestep
  /glstat/d000001/cycle:	integer(1) = current cycle number
  /glstat/d000001/ts_eltype:	integer(1) = type of element responsible for
				the current time step. 1=solid, 2=beam, etc.
  /glstat/d000001/ts_element:	integer(1) = user id of time step controling
				element.
  /glstat/d000001/kinetic_energy:	real(1) = KE
  /glstat/d000001/internal_energy:	real(1) = IE
  /glstat/d000001/stonewall_energy:	real(*) = energies of stonewalls, if any
  /glstat/d000001/rb_stopper_energy:	real(1) = well, you know
  /glstat/d000001/spring_and_damper_energy:	real(1) = well, you know
  /glstat/d000001/hourglass_energy:	real(1) = well, you know
  /glstat/d000001/system_damping_energy:	real(1) = well, you know
  /glstat/d000001/sliding_interface_energy:	real(1) = well, you know
  /glstat/d000001/external_work:	real(1) = well, you know
  /glstat/d000001/total_energy:		real(1) = well, you know
  /glstat/d000001/energy_ratio:		real(1) = well, you know
  /glstat/d000001/global_x_velocity:	real(1) = well, you know
  /glstat/d000001/global_y_velocity:	real(1) = well, you know
  /glstat/d000001/global_z_velocity:	real(1) = well, you know
  /glstat/d000001/nzc:			integer(1) = well, you know
  /glstat/d000001/num_bad_shells:	integer(1) = # reached min time step
  /glstat/d000001/added_mass:		real(1) = added mass
  /glstat/d000001/percent_increase:	real(1) = % mass increase

note: some of these things might not exist if there is no corresponding item
in the problem (rb_stopper_energy, stonewall_energy, etc).

===============================================================================
/ssstat -- Subsystem statistics.  Since ssstat implies the existance of glstat
           (at same output frequency), some of the common data is missing here
           and has to be picked up from there instead....
  /ssstat/metadata/systems: integer(*) = counts, for each subsystem,
	of the number of materials in the subsystem.  The length of this
	array is equal to the number of subsystems.
  /ssstat/metadata/ids: integer(*) = list of all materials of all
	subsystems.

For example, if there are two subsystems, and the first is materials 3 and
5 and the second is materials 2, 4 and 8, then

systems() = 2, 3
ids()     = 3, 5, 2, 4, 8

  /ssstat/d000001/kinetic_energy:	real(*) = KE
  /ssstat/d000001/internal_energy:	real(*) = IE
  /ssstat/d000001/hourglass_energy:	real(*) = well, you know
  /ssstat/d000001/x_momentum:		real(*) = well, you know
  /ssstat/d000001/y_momentum:		real(*) = well, you know
  /ssstat/d000001/z_momentum	:	real(*) = well, you know
  /ssstat/d000001/kinetic_energy_ratios:	real(*) = well, you know
  /ssstat/d000001/internal_energy_ratios:	real(*) = well, you know

===============================================================================
/deforc  -- Discrete element forces
  /deforc/metadata/title:	I*1(80)  = title from ls-dyna input file
  /deforc/metadata/version:     I*1(10) = version string from dyna
  /deforc/metadata/date:        I*1(10) = date string from dyna
  /deforc/metadata/ids:		integer(*) = list of user ids
  /deforc/metadata/irot:	integer(*)= "rotational" flags for each
                                discrete element.   1 indicates this element
                                is a torsional spring/damper
  /deforc/d000001/time:			real(1) = current simulation time
  /deforc/d000001/x_force:		real(*) = x force/moment
  /deforc/d000001/y_force:		real(*) = y force/moment
  /deforc/d000001/z_force:		real(*) = z force/moment
  /deforc/d000001/resultant_force:	real(*) = resultant force/moment
  /deforc/d000001/displacement:		real(*) = change in length/relative rotation

===============================================================================
/matsum  -- Material Summary file
  /matsum/metadata/title:	I*1(80)  = title from ls-dyna input file
  /matsum/metadata/version: I*1(10) = version string from dyna
  /matsum/metadata/date:    I*1(10) = date string from dyna
  /matsum/metadata/ids:		integer(*) = list of user ids for materials
  /matsum/metadata/legend: I*1(*) = strings to be printed in the legend --
                              each is 70 characters long, and they are
                              concatenated, so 4 legend entries=280 characters
  /matsum/metadata/legend_ids: integer(*) = list of id numbers to be printed
                              in the legend.
  /matsum/d000001/time:		real(1) = current simulation time
  /matsum/d000001/internal_energy:	real(*) = IE for each material
  /matsum/d000001/kinetic_energy:	real(*) = KE for each material
  /matsum/d000001/mass:			real(*) = mass for each material
  /matsum/d000001/x_momentum:		real(*) = X momentum
  /matsum/d000001/y_momentum:		real(*) = Y momentum
  /matsum/d000001/z_momentum:		real(*) = Z momentum
  /matsum/d000001/x_rbvelocity:		real(*) = X rigid body velocity
  /matsum/d000001/y_rbvelocity:		real(*) = Y rigid body velocity
  /matsum/d000001/z_rbvelocity:		real(*) = Z rigid body velocity
  /matsum/d000001/hourglass_energy:	real(*) = hourglass energy
  /matsum/d000001/max_brick_mass:	real(1) = mass of brick with most
						  added mass
  /matsum/d000001/brick_id:		integer(1) = user id of brick with most
						  added mass
  /matsum/d000001/max_beam_mass:	real(1) = mass of beam with most
						  added mass
  /matsum/d000001/beam_id:		integer(1) = user id of beam with most
						  added mass
  /matsum/d000001/max_shell_mass:	real(1) = mass of shell with most
						  added mass
  /matsum/d000001/shell_id:		integer(1) = user id of shell with most
						  added mass
  /matsum/d000001/max_thick_shell_mass:	real(1) = mass of thick shell with most
						  added mass
  /matsum/d000001/thick_shell_id:	integer(1) = user id of thick shell with
						  most added mass

===============================================================================
/ncforc -- Nodal interface forces

  There are possibly many subdirs immediately inside the "ncforc" directory,
  one for each side (master/slave) of each interface that has output turned
  on.  These directories will have names like "slave_xxxxx" or "master_xxxxx"
  where "xxxxx" is a 5 digit user id for the contact interface.
  The data structure inside each existing directory is identical, so I will
  use "slave_00001" as an example:

  /ncforc/slave_00001/metadata/title:	I*1(80)   = problem title
  /ncforc/slave_00001/metadata/version: I*1(10) = version string from dyna
  /ncforc/slave_00001/metadata/date:    I*1(10) = date string from dyna
  /ncforc/slave_00001/metadata/ids:	integer(*)= list of user ids for
					the nodes.
  /ncforc/slave_00001/metadata/legend:  I*1(70) = string to be printed in the
                                                  legend (if any)

  /ncforc/slave_00001/d000001/time:	real(1) = current simulation time
  /ncforc/slave_00001/d000001/x_force:	real(*) = x force
  /ncforc/slave_00001/d000001/y_force:	real(*) = y force
  /ncforc/slave_00001/d000001/z_force:	real(*) = z force
  /ncforc/slave_00001/d000001/pressure:	real(*) = pressure
  /ncforc/slave_00001/d000001/x:	real(*) = x coordinate
  /ncforc/slave_00001/d000001/y:	real(*) = y coordinate
  /ncforc/slave_00001/d000001/z:	real(*) = z coordinate

===============================================================================
/rcforc  -- Reaction force file for contacts
  /rcforc/metadata/title:	I*1(80)   = title from ls-dyna input file
  /rcforc/metadata/version: I*1(10) = version string from dyna
  /rcforc/metadata/date:    I*1(10) = date string from dyna
  /rcforc/metadata/ids:		integer(*)= list of user ids for contacts.
  /rcforc/metadata/side:	integer(*)= list of side flags for contacts.
  /rcforc/metadata/legend: I*1(*) = strings to be printed in the legend --
                              each is 70 characters long, and they are
                              concatenated, so 4 legend entries=280 characters
  /rcforc/metadata/legend_ids: integer(*) = list of id numbers to be printed
                              in the legend.

  A contact interface may show up more than once in the "ids" list if both
  its slave and master sides are being output.  For example, if "ids" contained
  1, 1, 3, 4, 4, 5 and "side" contained 0, 1, 1, 0, 1, 0, this would mean the
  following data was being output IN THIS ORDER:

   contact 1 slave side
   contact 1 master side
   contact 3 master side
   contact 4 slave side
   contact 4 master side
   contact 5 slave side

  /rcforc/d000001/time:		real(1) = current simulation time
  /rcforc/d000001/x_force:	real(*) = x force
  /rcforc/d000001/y_force:	real(*) = y force
  /rcforc/d000001/z_force:	real(*) = z force
  /rcforc/d000001/mass:		real(*) = mass (of what, nodes in contact?)

===============================================================================
/defgeo -- Smug animator database
  /defgeo/metadata/title:	I*1(80)   = title from ls-dyna input file
  /defgeo/metadata/ids:		integer(*)= list of user ids for nodes

  /defgeo/d000001/time:		real(1)= current simulation time
  /defgeo/d000001/nstate:	integer(1)= output state
  /defgeo/d000001/x_displacement:	real(*)= x displacements
  /defgeo/d000001/y_displacement:	real(*)= y displacements
  /defgeo/d000001/z_displacement:	real(*)= z displacements
  /defgeo/d000001/max_displacement:	real(1)= maximum (not absolute!?!)
						 displacement
===============================================================================
/spcforc -- SPC reaction forces
  /spcforc/metadata/title:	I*1(80)   = title from ls-dyna input file
  /spcforc/metadata/force_ids:	integer(*)= list of user ids for nodes that
						have translational forces
  /spcforc/metadata/moment_ids:	integer(*)= list of user ids for nodes that
						have rotational moments

  /spcforc/d000001/time:	real(1) = current simulation time
  /spcforc/d000001/x_force:	real(*) = x force for "force_ids" nodes
  /spcforc/d000001/y_force:	real(*) = y force for "force_ids" nodes
  /spcforc/d000001/z_force:	real(*) = z force for "force_ids" nodes
  /spcforc/d000001/x_moment:	real(*) = x moment for "moment_ids" nodes
  /spcforc/d000001/y_moment:	real(*) = y moment for "moment_ids" nodes
  /spcforc/d000001/z_moment:	real(*) = z moment for "moment_ids" nodes
  /spcforc/d000001/x_resultant:	real(1) = sum of x-force values
  /spcforc/d000001/y_resultant:	real(1) = sum of y-force values
  /spcforc/d000001/z_resultant:	real(1) = sum of z-force values
===============================================================================
/swforc  -- spotweld force file
  /swforc/metadata/title:	I*1(80)   = title from ls-dyna input file
  /swforc/metadata/ids:		integer(*)= list of user ids
  /swforc/metadata/version: I*1(10) = version string from dyna
  /swforc/metadata/date:    I*1(10) = date string from dyna
  /swforc/metadata/typenames:	character(36)= list of names of the different
  spotweld/constraint types.  This string currently reads
  "constraint,weld,beam,solid,non nodal"
  /swforc/metadata/types:	integer(*)= list of types, according to the
 "typenames" string: 1=constraint, 2=weld, etc.

  /swforc/d000001/time:		real(1) = current simulation time
  /swforc/d000001/axial:	real(*) = axial force
  /swforc/d000001/shear:	real(*) = shear force
  /swforc/d000001/length:	real(*) = spotweld length
  /swforc/d000001/failure_flag:	integer(*) = 0/1 flag, 1=failure
  /swforc/d000001/failure_time:	real(*) = Failure time
  /swforc/d000001/emom:        	real(*) = ???? but only output for non-nodal
                                          constraints......

===============================================================================
/abstat -- Airbag statistics
  /abstat/metadata/title:	I*1(80)   = title from ls-dyna input file
  /abstat/metadata/version: I*1(10) = version string from dyna
  /abstat/metadata/date:    I*1(10) = date string from dyna
  /abstat/metadata/ids:		integer(*)= list of user ids
  /abstat/metadata/legend: I*1(*) = strings to be printed in the legend --
                              each is 70 characters long, and they are
                              concatenated, so 4 legend entries=280 characters
  /abstat/metadata/legend_ids: integer(*) = list of id numbers to be printed
                              in the legend.

  /abstat/d000001/time:		real(1) = current simulation time
  /abstat/d000001/volume:	real(*) = airbag volume
  /abstat/d000001/pressure:	real(*) = current pressure
  /abstat/d000001/internal_energy:	real(*) = internal energy
  /abstat/d000001/dm_dt_in:	real(*) = incoming mass flow rate (dm/dt in)
  /abstat/d000001/density:	real(*) = density of (gas ????)
  /abstat/d000001/dm_dt_out:	real(*) = outgoing mass flow rate (dm/dt out)
  /abstat/d000001/total_mass:	real(*) = total mass of (gas ????)
  /abstat/d000001/gas_temp:	real(*) = current gas temperature
  /abstat/d000001/surface_area:	real(*) = airbage surface area
  /abstat/d000001/reaction:	real(*) = ?????

Note:  There is a option in the ascii output for blocked material info.  Last
 time I checked there were serious unresolved problems with this option
 (assuming 10 materials per bag in some places, 100 max.  But assuming 100
 per bag in other places!)  So I didn't put that in the lsda output at all....

===============================================================================
/avsflt -- ASCII database
  have no plans to implement
===============================================================================
/nodfor  -- nodal group force file
  /nodfor/metadata/title:	I*1(80)   = title from ls-dyna input file
  /nodfor/metadata/version:     I*1(10) = version string from dyna
  /nodfor/metadata/date:        I*1(10) = date string from dyna
  /nodfor/metadata/groups:	integer(*)= # of nodes in each force group
				(length = # of groups)
  /nodfor/metadata/ids:		integer(*)= list of user ids for all nodes
				(length = sum over all groups of group size)
  /nodfor/metadata/local:	integer(*)= local coord system # for local
				output (0 => "local" is the same as "global")


  /nodfor/d000001/time:		real(1) = current simulation time
  /nodfor/d000001/x_force:	real(*) = x force at each node
  /nodfor/d000001/y_force:	real(*) = y force at each node
  /nodfor/d000001/z_force:	real(*) = z force at each node
  /nodfor/d000001/energy:	real(*) = energy at each node
  /nodfor/d000001/x_total:	real(*) = total x force for each group
  /nodfor/d000001/y_total:	real(*) = total y force for each group
  /nodfor/d000001/z_total:	real(*) = total z force for each group
  /nodfor/d000001/etotal:	real(*) = total energy for each group
  /nodfor/d000001/x_local:	real(*) = total x force (in local system)
  /nodfor/d000001/y_local:	real(*) = total y force (in local system)
  /nodfor/d000001/z_local:	real(*) = total z force (in local system)

===============================================================================
/bndout  -- boundary conditions

There is a BUNCH of different kinds of stuff that are in this ascii file,
so I broke it down into 5 subdirs as follows:

/bndout/discrete/nodes		= discrete loads on nodes
/bndout/discrete/rigidbodies	= discrete loads on rigid bodies
/bndout/pressure		= pressure loads on nodes
/bndout/velocity/nodes		= velocity loads on nodes
/bndout/velocity/rigidbodies	= velocity loads on rigid bodies

Each of the 5 directories has a metadata directory with "title", "version",
"date" and "ids" in it.  If there is none of some output type, that
directory will not exist.  Beneath each of the 5 directories are the
 normal "d******" directories, and they all contain:

  .../d000001/time:	real(1) = current simulation time
  .../d000001/x_force:	real(*) = x force on each node/rigid body
  .../d000001/y_force:	real(*) = y force on each node/rigid body
  .../d000001/z_force:	real(*) = z force on each node/rigid body
  .../d000001/energy:	real(*) = energy at each node/rigid body
  .../d000001/x_total:	real(1) = total x force
  .../d000001/y_total:	real(1) = total y force
  .../d000001/z_total:	real(1) = total z force
  .../d000001/etotal:	real(1) = total energy

In addition to all these, the velocity/rigidbody/d??????/ directories
also contain:

  .../d000001/xmoment:	real(*) = x moment on each rigid body
  .../d000001/ymoment:	real(*) = y moment on each rigid body
  .../d000001/zmoment:	real(*) = z moment on each rigid body

===============================================================================
/rbdout  -- rigid body output
  /rbdout/metadata/title:	I*1(80)   = title from ls-dyna input file
  /rbdout/metadata/version: I*1(10) = version string from dyna
  /rbdout/metadata/date:    I*1(10) = date string from dyna
  /rbdout/metadata/ids:		integer(*)= user material ids
  /rbdout/metadata/num_nodal:	integer(1)= # that are nodal rigid bodies

  /rbdout/d000001/time:		real(1) = current simulation time
  /rbdout/d000001/cycle:	integer(1) = cycle number
  /rbdout/d000001/global_x:	real(*) = coord
  /rbdout/d000001/global_y:	real(*)
  /rbdout/d000001/global_z:	real(*)
  /rbdout/d000001/global_dx:	real(*) = displacement
  /rbdout/d000001/global_dy:	real(*)
  /rbdout/d000001/global_dz:	real(*)
  /rbdout/d000001/global_rdx:	real(*) = rotational displacement
  /rbdout/d000001/global_rdy:	real(*)
  /rbdout/d000001/global_rdz:	real(*)
  /rbdout/d000001/global_vx:	real(*) = velocity
  /rbdout/d000001/global_vy:	real(*)
  /rbdout/d000001/global_vz:	real(*)
  /rbdout/d000001/global_rvx:	real(*) = angular velocity
  /rbdout/d000001/global_rvy:	real(*)
  /rbdout/d000001/global_rvz:	real(*)
  /rbdout/d000001/global_ax:	real(*) = acceleration
  /rbdout/d000001/global_ay:	real(*)
  /rbdout/d000001/global_az:	real(*)
  /rbdout/d000001/global_rax:	real(*) = angular acceleration
  /rbdout/d000001/global_ray:	real(*)
  /rbdout/d000001/global_raz:	real(*)
  /rbdout/d000001/dircos_11:	real(*) = directional cosines
  /rbdout/d000001/dircos_12:	real(*)
  /rbdout/d000001/dircos_13:	real(*)
  /rbdout/d000001/dircos_21:	real(*)
  /rbdout/d000001/dircos_22:	real(*)
  /rbdout/d000001/dircos_23:	real(*)
  /rbdout/d000001/dircos_31:	real(*)
  /rbdout/d000001/dircos_32:	real(*)
  /rbdout/d000001/dircos_33:	real(*)
  /rbdout/d000001/local_dx:	real(*) = same stuff in local/principal dirs
  /rbdout/d000001/local_dy:	real(*)
  /rbdout/d000001/local_dz:	real(*)
  /rbdout/d000001/local_rdx:	real(*)
  /rbdout/d000001/local_rdy:	real(*)
  /rbdout/d000001/local_rdz:	real(*)
  /rbdout/d000001/local_vx:	real(*)
  /rbdout/d000001/local_vy:	real(*)
  /rbdout/d000001/local_vz:	real(*)
  /rbdout/d000001/local_rvx:	real(*)
  /rbdout/d000001/local_rvy:	real(*)
  /rbdout/d000001/local_rvz:	real(*)
  /rbdout/d000001/local_ax:	real(*)
  /rbdout/d000001/local_ay:	real(*)
  /rbdout/d000001/local_az:	real(*)
  /rbdout/d000001/local_rax:	real(*)
  /rbdout/d000001/local_ray:	real(*)
  /rbdout/d000001/local_raz:	real(*)
===============================================================================
/gceout -- Geometric contact entities
  /gceout/metadata/title:	I*1(80)   = title from ls-dyna input file
  /gceout/metadata/version:     I*1(10) = version string from dyna
  /gceout/metadata/date:        I*1(10) = date string from dyna
  /gceout/metadata/ids:		integer(*)= user material ids

  /gceout/d000001/time:		real(1) = current simulation time
  /gceout/d000001/x-force:	real(*) = x-force on each contact entity
  /gceout/d000001/y-force:	real(*) = y-force on each contact entity
  /gceout/d000001/z-force:	real(*) = z-force on each contact entity
  /gceout/d000001/x-moment:	real(*) = x-moment on each contact entity
  /gceout/d000001/y-moment:	real(*) = y-moment on each contact entity
  /gceout/d000001/z-moment:	real(*) = z-moment on each contact entity
  /gceout/d000001/force_magnitude:	real(*) = for each entity
  /gceout/d000001/moment_magnitude:	real(*) = for each entity
===============================================================================
/mpgs -- MPGS file
  no plans
===============================================================================
/movie -- MOVIE file
  no plans
===============================================================================
/sleout -- interface energies
  /sleout/metadata/title:	I*1(80)   = title from ls-dyna input file
  /sleout/metadata/version: 	I*1(10) = version string from dyna
  /sleout/metadata/date:    	I*1(10) = date string from dyna
  /sleout/metadata/ids:		integer(*)= user sliding interface ids
  /sleout/metadata/single_sided:integer(1)= 0/1 flag to indicate if this
				interface is single sided or not.  Those that
				are single sided will have no corresponding
				entry in the "master" array in the data
				directory, and so that array may be shorter
				than the "slave" array.

  /sleout/d000001/time:		real(1) = current simulation time
  /sleout/d000001/cycle:	integer(1) = cycle number
  /sleout/d000001/slave:	real(*) = energy for each slave side
  /sleout/d000001/master:	real(*) = energy for each master side
  /sleout/d000001/total_slave:	real(1) = sum of slave energies
  /sleout/d000001/total_master:	real(1) = sum of master energies
  /sleout/d000001/total_energy:	real(1) = sum of slave and master energies

===============================================================================
/sbtout -- Seat belts
  /sbtout/metadata/title:	I*1(80)   = title from input file
  /sbtout/metadata/version: 	I*1(10) = version string from dyna
  /sbtout/metadata/date:    	I*1(10) = date string from dyna
  /sbtout/metadata/belt_ids:	integer(*)= belt element ids
  /sbtout/metadata/slipring_ids:	integer(*)= slipring ids
  /sbtout/metadata/retractor_ids:	integer(*)= retractor ids

note: if there are no sliprings or retractors, then those ids and data simply
      do not appear in the file....

  /sbtout/d000001/time:		real(1) = current simulation time
  /sbtout/d000001/belt_force:		real(*) = force on each element
  /sbtout/d000001/belt_length:		real(*) = length of each element
  /sbtout/d000001/ring_slip:		real(*) = total slip from side 1 to
  /sbtout/d000001/retractor_pull_out:	real(*) = amount of belt pulled out
  /sbtout/d000001/retractor_force:	real(*) = current retractor force

===============================================================================
/jntforc -- Joint forces
There are three types of joint output: normal joints, and two types of
stiffness joints.  Hence there are three subdirectories immediately below
this directory: joints, type0, and type1.
  /jntforc/joints/metadata/title:	I*1(80)   = title from input file
  /jntforc/joints/metadata/version: 	I*1(10) = version string from dyna
  /jntforc/joints/metadata/date:    	I*1(10) = date string from dyna
  /jntforc/joints/metadata/ids:		integer(*)= user sliding interface ids
  /jntforc/joints/metadata/local:	integer(*)= 0/1 flag to indicate if
						output is in the global or
						local system.
  /jntforc/joints/metadata/legend: I*1(*) = strings to be printed in the legend --
                              each is 70 characters long, and they are
                              concatenated, so 4 legend entries=280 characters
  /jntforc/joints/metadata/legend_ids: integer(*) = list of id numbers to be printed
                              in the legend.
  .../joints/d000001/time:		real(1)= simulation time
  .../joints/d000001/x_force:		real(*)= force in x direction
  .../joints/d000001/y_force:		real(*)= force in y direction
  .../joints/d000001/z_force:		real(*)= force in z direction
  .../joints/d000001/x_moment:		real(*)= moment in x direction
  .../joints/d000001/y_moment:		real(*)= moment in y direction
  .../joints/d000001/z_moment:		real(*)= moment in z direction
  .../joints/d000001/resultant_force:	real(*)= yup, you guessed it
  .../joints/d000001/resultant_moment:	real(*)= original, huh?

  /jntforc/type0/metadata/title:	I*1(80)   = title from input file
  /jntforc/type0/metadata/ids:		integer(*)= user sliding interface ids
  /jntforc/type0/metadata/version: 	I*1(10) = version string from dyna
  /jntforc/type0/metadata/date:    	I*1(10) = date string from dyna
  /jntforc/type0/metadata/legend: I*1(*) = strings to be printed in the legend --
                              each is 70 characters long, and they are
                              concatenated, so 4 legend entries=280 characters
  /jntforc/type0/metadata/legend_ids: integer(*) = list of id numbers to be printed
                              in the legend.

  .../type0/d000001/time:		real(1)= simulation time
  .../type0/d000001/phi_degrees:	real(*)= phi in degrees
  .../type0/d000001/d(phi)_dt:		real(*)= d/dt of phi in degrees
  .../type0/d000001/theta_degrees:	real(*)= theta in degrees
  .../type0/d000001/d(theta)_dt:	real(*)= d/dt of theta in degrees
  .../type0/d000001/psi_degrees:	real(*)= psi in degrees
  .../type0/d000001/d(psi)_dt:		real(*)= d/dt of psi in degrees
  .../type0/d000001/phi_moment_stiffness:	real(*)= If I knew I'd tell you
  .../type0/d000001/phi_moment_damping:		real(*)= 
  .../type0/d000001/phi_moment_total:		real(*)= 
  .../type0/d000001/theta_moment_stiffness:	real(*)=
  .../type0/d000001/theta_moment_damping:	real(*)= 
  .../type0/d000001/theta_moment_total:		real(*)= 
  .../type0/d000001/psi_moment_stiffness:	real(*)=
  .../type0/d000001/psi_moment_damping:		real(*)= 
  .../type0/d000001/psi_moment_total:		real(*)= 
  .../type0/d000001/joint_energy:		real(*)=

  /jntforc/type1/metadata/title:	I*1(80)   = title from input file
  /jntforc/type1/metadata/ids:		integer(*)= user sliding interface ids
  /jntforc/type1/metadata/version: 	I*1(10) = version string from dyna
  /jntforc/type1/metadata/date:    	I*1(10) = date string from dyna
  /jntforc/type1/metadata/legend: I*1(*) = strings to be printed in the legend --
                              each is 70 characters long, and they are
                              concatenated, so 4 legend entries=280 characters
  /jntforc/type1/metadata/legend_ids: integer(*) = list of id numbers to be printed
                              in the legend.

  .../type1/d000001/time:		real(1)= simulation time
  .../type1/d000001/alpha_degrees:	real(*)= alpha in degrees
  .../type1/d000001/d(alpha)_dt:	real(*)= d/dt of alpha in degrees
  .../type1/d000001/gamma_degrees:	real(*)= gamma in degrees
  .../type1/d000001/d(gamma)_dt:	real(*)= d/dt of gamma in degrees
  .../type1/d000001/beta_degrees:	real(*)= beta in degrees
  .../type1/d000001/d(beta)_dt:		real(*)= d/dt of beta in degrees
  .../type1/d000001/alpha_moment_stiffness:	real(*)= If I knew I'd tell you
  .../type1/d000001/alpha_moment_damping:	real(*)= 
  .../type1/d000001/alpha_moment_total:		real(*)= 
  .../type1/d000001/gamma_scale_factor:		real(*)=
  .../type1/d000001/beta_moment_stiffness:	real(*)=
  .../type1/d000001/beta_moment_damping:	real(*)= 
  .../type1/d000001/beta_moment_total:		real(*)= 
  .../type1/d000001/joint_energy:		real(*)=

===============================================================================

===============================================================================
/trhist -- Tracer partcles
  still to do
===============================================================================

/trprint -- thermal output
  still to do
===============================================================================
/sphout  -- Node data
  /sphout/metadata/title: I*1(80) = title from ls-dyna input file
  /sphout/metadata/version: I*1(10) = version string from dyna
  /sphout/metadata/date:    I*1(10) = date string from dyna
  /sphout/metadata/ids: integer(*) = list of user numbers for nodes
  /sphout/metadata/mat: integer(*) = list of material numbers for each node
  /sphout/metadata/states: I*1(15) = comma separated list of names
         corresponding to the "state" of the particle.  This string currently
         reads "elastic,plastic".  See the "state" array below.

 /sphout/d000001/time:		real(1) = current simulation time
 /sphout/d000001/cycle:		integer(1) = current simulation time step
 /sphout/d000001/act :          integer(*) = activation of particle
 /sphout/d000001/density :      real(*) = density
 /sphout/d000001/effsg :        real(*) = effective stress
 /sphout/d000001/eps_xx:	real(*) = XX strain
 /sphout/d000001/eps_xy:	real(*) = XY strain
 /sphout/d000001/eps_yy:	real(*) = YY strain
 /sphout/d000001/eps_yz:	real(*) = YZ strain
 /sphout/d000001/eps_zx:	real(*) = ZX strain
 /sphout/d000001/eps_zz:	real(*) = ZZ strain
 /sphout/d000001/neigh:         integer(*) = number of neighbors
 /sphout/d000001/sig_xx:	real(*) = XX stress
 /sphout/d000001/sig_xy:	real(*) = XY stress
 /sphout/d000001/sig_yy:	real(*) = YY stress
 /sphout/d000001/sig_yz:	real(*) = YZ stress
 /sphout/d000001/sig_zx:	real(*) = ZX stress
 /sphout/d000001/sig_zz:	real(*) = ZZ stress
 /sphout/d000001/smooth:        real(*) = smoothing length
 /sphout/d000001/state:         integer(*) = integer in the range 1-2
        			according to the state of the particle
        			(translate to names from the
        			"metadata/states" array)
 /sphout/d000001/yield: 	real(*) = yield surface

===============================================================================

Still to do, in order of priority (according to Dilip):

trhist
tprint

status of cleanup/translation code:

  secforc -- done
  rwforc  -- done (rigid wall segments not tested...)
  nodout  -- done
  elout   -- checked all but thick shells
  glstat  -- done
  ssstat  -- done
  deforc  -- done
  matsum  -- done
  ncforc  -- done
  rcforc  -- done
  defgeo (have to get from dumpbdb...)
  spcforc -- done
  swforc  -- tested a bit, but non-nodal untested among others.
  abstat  -- done
  nodfor  -- done
  bndout  -- done
  rbdout  -- done
  gceout  -- done, but multiple materials with same entity are wrong.  Maybe
             we should output GCE id AND material #?
  sleout  -- done
  sbtout  -- done
  jntforc -- done
  sphout -- done
