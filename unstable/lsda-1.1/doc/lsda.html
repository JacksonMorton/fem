<html>
<head>
<title>LSTC Data Archival Routines</title>
<style type="text/css">
<!--
h3.fn,span.fn { margin-left: 15%; text-indent: -15%; }
a:link { text-decoration: none; }
-->
span.fn { margin-left: 15%; text-indent: -15%; }
</style>
</head><body bgcolor="#ffffff">
<!-- ============================================================ -->
<h1 align=center>
<strong>LSTC Data Archival Routines</strong>
</h1><br clear="all">
<hr>
<!-- ============================================================ -->
<p>
<i>
The database files written by LS-DYNA all have a fixed structure.  This
makes it difficult, if not impossible, to add new data or support new
features without breaking compatibility with existing post processors.
These routines were designed to solve this problem by providing an
extemely flexible file format and set of library routines for reading
and writing such files.
<p>
We give a brief description of how to use the package, followed by a
more detailed description of each of the functions.
</i>
<p>
--- Brian Wainscott, <tt>brian@lstc.com</tt>
<br>
--- Trent Eggleston, <tt>trent@lstc.com</tt>
<p>
<hr>
<h3>Basic Structure</h3> 
The file is set up to appear like a standard UNIX directory structure.  Data
is stored in variables which act like files, and are organized by belonging
to directories, just like files would.  Each "file" of data has a name,
length, and type.  The problem of adding new data is eliminated, because
any postprocessor that doesn't know about your new data can just ignore it
without difficulty.
<p>
<h3>Special Features/Advantages</h3> 
<ul>
<li> Portability <br>
Files written in the LSTC Data Archive format are completely portable.  The
library routines take care of any necessary translations when reading data
written on a machine with a different binary format.
<li> Reliability <br>
The data file contains enough redundant information to provide complete
data integrity.  If the program should crash, any and all data actually
written to the disk is fully recoverable.  The symbol table (data layout and
file structure information) can be recreated from the data itself.
<li> Backward Compatibility <br>
A user program can be modified to output more data without breaking any
pre-existing post processor.  The post-processor will not be bothered in any
way by the existance of data it did not expect -- a serious problem with
traditional ascii formatted files, where the post-processor had to know
everything about the layout of the file in order to read it successfully.
</ul>
<h3>Limitations</h3> 
Because this package was intended for use in LS-DYNA, the routines are
designed around the idea of data being "write once, read many."  Data is
written to the file in the native format of the machine it is running on,
and there are no facilities for deleting or modifying data that has
been written.
<h3>Usage Overview</h3> 
Here is a brief example, with explaination following:
<pre>
int dbh;
daf = lsda_open("myfile",LSDA_WRITEONLY);
lsda_cd(daf,"/matsum/md1");
lsda_write(daf,LSDA_FLOAT,"Time",1,tt);
lsda_write(daf,LSDA_FLOAT,"Velocity",100,vel1);
lsda_write(daf,LSDA_FLOAT,"Displacement",100,disp1);
lsda_cd(daf,"../md2");
lsda_write(daf,LSDA_FLOAT,"Time",1,tt);
lsda_write(daf,LSDA_FLOAT,"Velocity",100,vel2);
lsda_write(daf,LSDA_FLOAT,"Displacement",100,disp2);
lsda_close(daf);
</pre>
lsda_open returns an integer, which acts as a handle to this file.  The lsda_cd
command changes the "working directory" where the data will be written.
The lsda_write command writes one array.  It requires the data type and 
name, as well as the length and data.
<p>
To read, for example, the second set of displacements written above, you
could do this:
<pre>
int daf;
daf = lsda_open("myfile",LSDA_READONLY);
lsda_cd(dbh,"/matsum/md2");
lsda_read(dbh,LSDA_FLOAT,"Velocity",100,vel2);
lsda_close(dbh);
</pre>

or even this:

<pre>
int daf;
daf = lsda_open("myfile",LSDA_READONLY);
lsda_read(daf,LSDA_FLOAT,"/matsum/md2/Velocity",100,vel2);
lsda_close(daf);
</pre>
<h3>Intrinsic Data Types</h3> 
The following data types are recognized by the libaray:

<li> <tt>I*1, I*2, I*4, I*8</tt> are length specific signed integers
<li> <tt>U*1, U*2, U*4, U*8</tt> are length specific unsigned integers
<li> <tt>R*4, R*8</tt> are length specific real numbers
<li> <tt>int, short, long, unsigned int, unsigned short, unsigned long, float,
         double</tt> are the machine specific C datatypes.
<li> <tt>integer, real, double precision</tt> are the machine specific
         Fortran datatypes.
</li>
When reading data, conversions are performed as necessary to convert from the
type of data as written to the type of data being read, with the following
limitations:
<li> Conversions between real and integer types are not supported
<li> If either the written or read datatype is unsigned, unsigned
conversions are performed
</li>

<h3>Defined Constants</h3> 
The following constants are defined in the header files and used to
indicate the type of data to be read/written:
<li>
<tt>LSDA_I1, LSDA_I2, LSDA_I4, LSDA_I8</tt> for length specific signed integers
<li>
<tt>LSDA_U1, LSDA_U2, LSDA_U4, LSDA_U8</tt> for length specific unsigned integers
<li>
<tt>LSDA_R4,  LSDA_R8</tt> for length specific reals
<li>
<tt>LSDA_INT, LSDA_SHORT, LSDA_LONG, LSDA_USHORT, LSDA_UINT, LSDA_ULONG,
LSDA_FLOAT, LSDA_DOUBLE</tt> for intrinsic C data types
<li>
<tt>LSDA_INTEGER, LSDA_REAL, LSDA_DP</tt> for intrinsic Fortran data types
</li>
<br><br>
The defined constants <tt>LSDA_READONLY, LSDA_WRITEONLY</tt> are used for
indicating file open modes.
<br><br>
The constant <tt>LSDA_SUCCESS</tt> is the error value which indicates that
no error occured.  In C, the variable <tt>lsda_errno</tt> contains the
error number of the last error that occured.
<h3>Familied Files</h3> 
In order to keep individual files from getting too big while still allowing
the apparent file to be very large, a file can be split into several pieces
while it is being written.  This is NOT done automatically, but must
be done explicitly.  By default, a single file is created with the name
as given at creation time, and the file number is 0.  At any time, a
call to lsda_nextfile may be issued.  This will close the current file,
open the next file in order, and return the number of the new file opened.
The new file name is generated by appending %XXX onto the given file name,
where XXX is a 3 (or more) digit number.
</p>
<hr>
<!-- ============================================================ -->
<h2> C bindings </h2>
All C source files referencing these routines should include the
header file "lsda.h"
<br>
For all routines, an error is indicated by a return value of -1.
<hr>
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<h3> File Handling Routines</h3>
<ul>
<li> <span class="fn">
     int
     <a href="#_lsda_open"><strong>lsda_open</strong></a> 
     ( char *filen, int mode )
     </span>
<li> <span class="fn">
     int
     <a href="#_lsda_open_many"><strong>lsda_open_many</strong></a> 
     ( char **filen, int num )
     </span>
<li> <span class="fn">
     int
     <a href="#_lsda_close"><strong>lsda_close</strong></a> 
     ( int handle )
     </span>
<li> <span class="fn">
     int
     <a href="#_lsda_reopen"><strong>lsda_reopen</strong></a> 
     ( char *filen, int filenum, LSDA_Offset offset )
     </span>
<li> <span class="fn">
     int
     <a href="#_lsda_fopen"><strong>lsda_fopen</strong></a> 
     ( char *filen, int filenum, LSDA_Offset offset, int handle )
     </span>
<li> <span class="fn">
     LSDA_Length 
     <a href="#_lsda_fsize"><strong>lsda_fsize</strong></a> 
     ( int handle )
     </span>
<li> <span class="fn">
     int
     <a href="#_lsda_filenum"><strong>lsda_filenum</strong></a>
     ( int handle )
     </span>
<li> <span class="fn">
     int 
     <a href="#_lsda_nextfile"><strong>lsda_nextfile</strong></a> 
     ( int handle )
     </span>
<li> <span class="fn">
     int 
     <a href="#_lsda_nextopen"><strong>lsda_nextopen</strong></a> 
     ( int handle )
     </span>
</ul>
<!-- ============================================================ -->
<h3> I/O Routines</h3>
<ul>
<li> <span class="fn">
     int
     <a href="#_lsda_cd"><strong>lsda_cd</strong></a> 
     ( int handle, char *path )
     </span>
<li> <span class="fn">
     int
     <a href="#_lsda_flush"><strong>lsda_flush</strong></a> 
     ( int handle )
     </span>
<li> <span class="fn">
     int
     <a href="#_lsda_write"><strong>lsda_write</strong></a> 
     ( int handle, int typeid, char *name, LSDA_Length length, void *data )
     </span>
<li> <span class="fn">
     int
     <a href="#_lsda_read"><strong>lsda_read</strong></a> 
     ( int handle, int typeid, char *name, int offset, int number, void *data )
     </span>
</ul>
<!-- ============================================================ -->
<h3> Inquiry Routines </h3>
<ul>
<li> <span class="fn">
     int
     <a href="#_lsda_test"><strong>lsda_test</strong></a> 
     ( char *filen )
     </span>
<li> <span class="fn">
     LSDADir * 
     <a href="#_lsda_opendir"><strong>lsda_opendir</strong></a> 
     ( int handle, char *path )
     </span>
<li> <span class="fn">
     int
     <a href="#_lsda_readdir"><strong>lsda_readdir</strong></a> 
     ( LSDADir *dir, char *name, int *typeid, LSDA_Length *length, int *filenum)
     </span>
<li> <span class="fn">
     int
     <a href="#_lsda_queryvar"><strong>lsda_queryvar</strong></a> 
     ( int handle, char *name, int *typeid, LSDA_Length *length, int *filenum)
     </span>
<li> <span class="fn">
     int
     <a href="#_lsda_closedir"><strong>lsda_closedir</strong></a> 
     ( LSDADir *dir )
     </span>
<li> <span class="fn">
     char *
     <a href="#_lsda_getpwd"><strong>lsda_getpwd</strong></a> 
     ( int handle )
     </span>
<li> <span class="fn">
     char *
     <a href="#_lsda_getname"><strong>lsda_getname</strong></a> 
     ( int handle )
     </span>
<li> <span class="fn">
     char *
     <a href="#_lsda_getbasename"><strong>lsda_getbasename</strong></a> 
     ( int handle )
     </span>
<li> <span class="fn">
     int
     <a href="#_lsda_gethandle"><strong>lsda_gethandle</strong></a> 
     ( char * filename )
     </span>
<li> <span class="fn">
     LSDA_Length
     <a href="#_lsda_totalmemory"><strong>lsda_totalmemory</strong></a> 
     ( int handle )
     </span>
</ul>
<!-- ============================================================ -->
<h3> Error Handling </h3>
<ul>
<li> <span class="fn">
     void
     <a href="#_lsda_setreportlevel"><strong>lsda_setreportlevel</strong></a> 
     ( int level )
     </span>
<li> <span class="fn">
     void
     <a href="#_lsda_perror"><strong>lsda_perror</strong></a> 
     ( char * string )
     </span>
</ul>
<hr>
<!-- ============================================================ -->
<h2> Fortran bindings </h2>
All Fortran source files referencing these routines should include the
header file "lsda.inc"
<br>
All Fortran routines return an error status in the last argument.  If the
value returned is not LSDA_SUCCESS, then an error has occured.
<hr>
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<h3> File Handling Routines</h3>
<ul>
<li> <span class="fn">
     integer function
     <a href="#_lsdaopen"><strong>lsdaopen</strong></a> 
     ( filen, mode ,ierr )
     <br>
     character*(*) filen
     <br>
     integer mode
     <br>
     integer ierr
     </span>
<li> <span class="fn">
     subroutine
     <a href="#_lsdaclose"><strong>lsdaclose</strong></a> 
     ( handle, ierr )
     <br>
     integer handle
     <br>
     integer ierr
     </span>
<li> <span class="fn">
     integer function
     <a href="#_lsdareopen"><strong>lsdareopen</strong></a> 
     ( filen, filenum, offset, ierr )
     <br>
     character*(*) filen
     <br>
     integer filenum
     <br>
     integer offset
     <br>
     integer ierr
     </span>
<li> <span class="fn">
     integer function
     <a href="#_lsdafopen"><strong>lsdafopen</strong></a> 
     ( filen, filenum, offset, handle, ierr )
     <br>
     character*(*) filen
     <br>
     integer filenum
     <br>
     integer offset
     <br>
     integer handle
     <br>
     integer ierr
     </span>
<li> <span class="fn">
     integer function
     <a href="#_lsdafsize"><strong>lsdafsize</strong></a> 
     ( handle, ierr )
     <br>
     integer handle
     <br>
     integer ierr
     </span>
<li> <span class="fn">
     integer function
     <a href="#_lsdafilenum"><strong>lsdafilenum</strong></a> 
     ( handle, ierr )
     <br>
     integer handle
     <br>
     integer ierr
     </span>
<li> <span class="fn">
     subroutine
     <a href="#_lsdanextfile"><strong>lsdanextfile</strong></a> 
     ( handle, ierr )
     <br>
     integer handle
     <br>
     integer ierr
     </span>
<li> <span class="fn">
     integer function
     <a href="#_lsdanextopen"><strong>lsdanextopen</strong></a> 
     ( handle, ierr )
     <br>
     integer handle
     <br>
     integer ierr
     </span>
</ul>
<!-- ============================================================ -->
<h3> File I/O Routines</h3>
<ul>
<li> <span class="fn">
     subroutine
     <a href="#_lsdacd"><strong>lsdacd</strong></a> 
     ( handle, path, ierr )
     <br>
     integer handle
     <br>
     character*(*) path
     <br>
     integer ierr
     </span>
<li> <span class="fn">
     subroutine
     <a href="#_lsdaflush"><strong>lsdaflush</strong></a> 
     ( handle, ierr )
     <br>
     integer handle
     <br>
     integer ierr
     </span>
<li> <span class="fn">
     subroutine
     <a href="#_lsdawrite"><strong>lsdawrite</strong></a> 
     ( handle, typeid, name, length, data, ierr )
     <br>
     integer handle
     <br>
     integer typeid
     <br>
     character*(*) name
     <br>
     integer length
     <br>
     integer data(*)
     <br>
     integer ierr
     </span>
<li> <span class="fn">
     subroutine
     <a href="#_lsdaread"><strong>lsdaread</strong></a> 
     ( handle, typeid, name, offset, number, data, ierr )
     <br>
     integer handle
     <br>
     integer typeid
     <br>
     character*(*) name
     <br>
     integer offset
     <br>
     integer number
     <br>
     integer data(*)
     <br>
     integer ierr
     </span>
</ul>
<hr>
<!-- ============================================================ -->
<h3> Inquiry Routines </h3>
<ul>
<li> <span class="fn">
     subroutine
     <a href="#_lsdaqueryvar"><strong>lsdaqueryvar</strong></a> 
     ( handle, name, typeid, length, filenum, ierr)
     <br>
     integer handle
     <br>
     character*(*) name
     <br>
     integer typeid
     <br>
     integer length
     <br>
     integer filenum
     <br>
     integer ierr
     </span>
<li> <span class="fn">
     integer function
     <a href="#_lsdaopendir"><strong>lsdaopendir</strong></a> 
     ( handle, path, ierr )
     <br>
     integer handle
     <br>
     character*(*) path
     <br>
     integer ierr
     </span>
<li> <span class="fn">
     subroutine
     <a href="#_lsdareaddir"><strong>lsdareaddir</strong></a> 
     ( dir, name, typeid, length, filenum, ierr )
     <br>
     integer dir
     <br>
     character*(*) name
     <br>
     integer typeid
     <br>
     integer length
     <br>
     integer filenum
     <br>
     integer ierr
     </span>
<li> <span class="fn">
     subroutine
     <a href="#_lsdaclosedir"><strong>lsdaclosedir</strong></a> 
     ( dir, ierr )
     <br>
     integer dir
     <br>
     integer ierr
     </span>
</ul>
These haven't been written yet, but when they are they should look like this.
<ul>
<li> <span class="fn">
     subroutine
     <a href="#_lsdagetpwd"><strong>lsdagetpwd</strong></a> 
     ( handle, path, ierr )
     <br>
     integer handle
     <br>
     character*(*) path
     <br>
     integer ierr
     </span>
<li> <span class="fn">
     subroutine
     <a href="#_lsdagetname"><strong>lsdagetname</strong></a> 
     ( handle, name, length, ierr )
     <br>
     integer handle
     <br>
     character*(*) path
     <br>
     integer length
     <br>
     integer ierr
     </span>
<li> <span class="fn">
     subroutine
     <a href="#_lsdagetbasename"><strong>lsdagetbasename</strong></a> 
     ( handle, name, length, ierr )
     <br>
     integer handle
     <br>
     character*(*) name
     <br>
     integer length
     <br>
     integer ierr
     </span>
<li> <span class="fn">
     subroutine
     <a href="#_lsdagethandle"><strong>lsdagethandle</strong></a> 
     ( name, ierr )
     <br>
     character*(*) name
     <br>
     integer ierr
     </span>
</ul>
<!-- ============================================================ -->
<h3> Fortran Error Handling </h3>
<ul>
<li> <span class="fn">
     subroutine
     <a href="#_lsdasetrlevel"><strong>lsdasetrlevel</strong></a> 
     ( level, ierr )
     <br>
     integer level
     <br>
     integer ierr
     </span>
<li> <span class="fn">
     subroutine
     <a href="#_lsdaperror"><strong>lsdaperror</strong></a> 
     ( string, ierr )
     <br>
     character string
     <br>
     integer ierr
     </span>
</ul>
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<hr>
<!-- ============================================================ -->
<h2> Details of Routines </h2>
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<h3> File Handling Routines</h3>
<ul>
<li> <h4>
     int
     <a name="_lsda_open">lsda_open</a> 
     ( char *filen, int mode )
     <br>
     <br>
     integer function <a name="_lsdaopen">lsdaopen </a> ( filen, mode, ierr )
     <br>
     character*(*) filen
     <br>
     integer mode
     <br>
     integer ierr
     </h4>
     Opens the indicated file for reading (<code>mode</code> = LSDA_READONLY) or
     writing (<code>mode</code> = LSDA_WRITEONLY).  If opened for writing, any
     existing data in the file is lost.  It returns a handle to the file.
     <p>
<li> <h4>
     int
     <a name="_lsda_open_many">lsda_open_many</a> 
     ( char **filen, int num )
     <br>
     <br>
     There is no FORTRAN implementation of this function at present
     </h4>
     This behaves just like <code>lsda_open</code> except that it takes an
     array of file names, and the number of names in the array.  ALL the
     files (and their "family" members) are opened for reading.  The symbol
     tables of all of them are read and the collection is treated as a
     single file.
     <p>
<li> <h4>
     int
     <a name="_lsda_close">lsda_close</a> 
     ( int handle )
     <br>
     <br>
     subroutine <a name="_lsdaclose">lsdaclose </a> ( handle )
     <br>
     integer handle
     <br>
     integer ierr
     </h4>
     Closes the file.
     <p>
<li> <h4>
     int
     <a name="_lsda_reopen">lsda_reopen</a> 
     ( char *filen, int filenum, LSDA_Offset offset )
     <br>
     <br>
     integer function <a name="_lsdareopen">lsdareopen </a>
      ( filen, filenum, offset, ierr )
     <br>
     character*(*) filen
     <br>
     integer filenum
     <br>
     integer offset
     <br>
     integer ierr
     </h4>
     Opens the file for appending, after throwing out all data after
     the given family member number and file offset.  It returns a file handle
     of the open file.  The offset and filenumber must correspond to the
     end of a symbol table block in the file, so that the file is complete
     after the truncation takes place.  The proper way to use this function
     is as follows:
<br>
     When you reach a point at which you might later want to reopen a file,
     call lsda_flush to flush all data and symbol table information.  Then
     call lsda_filenum and lsda_fsize to get the necessary values of
     filenum and offset.
     <p>
<li> <h4>
     int
     <a name="_lsda_fopen">lsda_fopen</a> 
     ( char *filen, int filenum, LSDA_Offset offset, int handle)
     <br>
     <br>
     integer function <a name="_lsdafopen">lsdafopen </a>
      ( filen, filenum, offset, handle, ierr )
     <br>
     character*(*) filen
     <br>
     integer filenum
     <br>
     integer offset
     <br>
     integer handle
     <br>
     integer ierr
     </h4>
     Just like lsda_reopen, but you pass in the handle you want the file
     assigned to.  If this handle is already in use, it is an error.
     If you pass in a negative number, a handle is assigned for you.
     This is intended for use when restarting a problem, so you can
     reopen all your files the way they were before.
     <p>
<li> <h4>
     LSDA_Length
     <a name="_lsda_fsize">lsda_fsize</a> 
     ( int handle )
     <br>
     <br>
     integer function <a name="_lsdafsize">lsdafsize </a> ( handle, ierr )
     <br>
     integer handle
     <br>
     integer ierr
     </h4>
     Returns the current file size in bytes.  The returned value does not
     include the size required by any unwritten symbol table data (variable
     names and directory structure) that has accumulated since the last call
     to lsda_flush.  Hence the file my be larger than this number when it
     is closed.  If the file has just been flushed, this number is accurate.
     <p>
<li> <h4>
     int
     <a name="_lsda_filenum">lsda_filenum</a> 
     ( int handle )
     <br>
     <br>
     integer function <a name="_lsdafilenum">lsdafilenum </a> ( handle, ierr )
     <br>
     integer handle
     <br>
     integer ierr
     </h4>
     Returns the current family member number for this file.
     <p>
<li> <h4>
     int
     <a name="_lsda_nextfile">lsda_nextfile</a> 
     ( int handle )
     <br>
     <br>
     subroutine <a name="_lsdanextfile">lsdanextfile </a> ( handle, ierr )
     <br>
     integer handle
     <br>
     integer ierr
     </h4>
     Closes the current family member, increments the member number,
     and opens the new family member.  In C, it returns the new member number.
     <p>
<li> <h4>
     int
     <a name="_lsda_nextopen">lsda_nextopen</a> 
     ( int handle )
     <br>
     <br>
     integer function <a name="_lsdanextopen">lsdanextopen </a> ( handle, ierr )
     <br>
     integer handle
     <br>
     integer ierr
     </h4>
     Returns the next currently open file handle.  This is used to loop
     over all open files.  The initial call should have handle=-1.  -1
     will be returned when no more open file handles are found.
     <p>
</ul>
<h3> I/O Routines</h3>
<ul>
<li> <h4>
     int
     <a name="_lsda_cd">lsda_cd</a> 
     ( int handle , char * path)
     <br>
     <br>
     subroutine <a name="_lsdacd">lsdacd </a> ( handle , path, ierr)
     <br>
     integer handle
     <br>
     character*(*) path
     <br>
     integer ierr
     </h4>
     Changes the current working directory in the file
     to <code>path</code>.
     <p>
<li> <h4>
     int
     <a name="_lsda_flush">lsda_flush</a> 
     ( int handle )
     <br>
     <br>
     subroutine <a name="_lsdaflush">lsdaflush </a> ( handle, ierr )
     <br>
     integer handle
     <br>
     integer ierr
     </h4>
     Flushes all variable data to the disk, and writes any new symbol table
     data to the disk.  At this point, the file as it exists on the disk
     is complete.
     <p>
<li> <h4>
     int
     <a name="_lsda_write">lsda_write</a> 
     ( int handle, int typeid, char *name, LSDA_Length length, void *data)
     <br>
     <br>
     subroutine <a name="_lsdawrite">lsdawrite </a>
     ( handle, typeid, name, length, data, ierr )
     <br>
     integer handle
     <br>
     integer typeid
     <br>
     character*(*) name
     <br>
     integer length
     <br>
     integer data(*)
     <br>
     integer ierr
     </h4>
     Writes new data to the file.  If <code>name</code> is not the empty
     string, a new entry in the file is created.  <code>typename</code>
     must match one of the built in data types, which are case sensitive:

<li> <tt>I*1, I*2, I*4, I*8</tt> are length specific signed integers
<li> <tt>U*1, U*2, U*4, U*8</tt> are length specific unsigned integers
<li> <tt>R*4, R*8</tt> are length specific real numbers
<li> <tt>int, short, long, unsigned int, unsigned short, unsigned long, float,
         double</tt> are the machine specific C datatypes.
<li> <tt>integer, real, double precision</tt> are the machine specific
         Fortran datatypes.
</li>
<br>
     The <code>name</code> of the variable may contain an optional
     complete or relative path component.  <code>length</code> indicats
     how many entries of the specified type are to be written, and the
     data is taken from <code>data</code>.  If <code>name</code> is the
     empty string and the last call to one of these routines was a call
     to lsda_write, then <code>typename</code> is ignored.  The type of the
     data is taken to be the same as the last variable written, and
     <code>length</code> entries are appended to that variable
     from <code>data</code>.  If any intermediate call was made that
     would change the state of the file (flush, nextfile, etc), then it
     is an error.
<br>
     In C, the return value is the number of items written to disk.
     <p>
<li> <h4>
     int
     <a name="_lsda_read">lsda_read</a> 
     ( int handle, int typeid, char *name, int offset, int number, void *data)
     <br>
     <br>
     subroutine <a name="_lsdaread">lsdaread </a>
     ( handle, typeid, name, offset, number, data, ierr )
     <br>
     integer handle
     <br>
     integer typeid
     <br>
     character*(*) name
     <br>
     integer offset
     <br>
     integer number
     <br>
     integer data(*)
     <br>
     integer ierr
     </h4>
     Reads data from the file.  <code>name</code> must correspond to a
     variable in the file (in the current directory, unless it contains
     an optional path component).  <code>typename</code> must be compatible
     with the type of the variable in the file.  Any data written with
     a signed integer type my be read with any other signed integer type.
     Conversion is performed as needed. Similarly with unsigned integers
     and floating point data.  Conversions between signed and unsigned
     integers will be performed as if all data were unsigned.  Conversions
     between integer and real data are not supported.  <code>offset</code>
     specifies the first entry in the variable to be read, with 0
     representing the beginning of the variable.  <code>number</code> is the
     number of variables to read.  The data is placed in <code>data</code>.
<br>
     In C, the return value is the number of items successfully read.
     <p>
</ul>
<h3> Inquiry Routines</h3>
<ul>
<li> <h4>
     LSDA_Length
     <a name="_lsda_totalmemory">lsda_totalmemory</a> 
     ( int handle )
     <br>
     </h4>
     Returns the total number of bytes of storage actually used by the
     data in the file.  This can be used to estimate the memory required
     to read in all the data.
</ul>
<!-- ============================================================ -->
</html>
